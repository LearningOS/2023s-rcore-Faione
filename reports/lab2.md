# lab2

## 编程作业

### 重写 sys_get_time 和 sys_task_info

**分析**

引入虚拟地址空间后，用户程序在进行系统调用时，传入的是自己地址空间中的变量的虚拟地址，而在内核地址空间中，这一虚拟i地址无法找到真正的变量。

**思路**

在 `os/src/mm/page_table.rs` 中增加 `translated_refmut<T>`，能够将用户虚拟地址空间中的变量实际物理地址对应的变量，从而能够直接对变量进行修改，逻辑如下:
- 获取当前用户的token, 以及变量的虚拟地址
- 利用 `token` 获取 page table
- 遍历 page table 找到对应的页表项，进而找到实际的物理页，与虚拟地址中的页偏移相加得到变量的物理地址
- 将物理地址进行裸指针转化为变量进行操作

**问题**

这种转化方式存在一个问题，即只进行了一次转化工作，如果变量存在跨页，则必然导致错误的读取/写入，而为解决这个问题，则需要对变量进行逐页的处理


### mmap 和 munmap 匿名映射

**思路**

mm模块是一个典型的分层模块，每层各自完成对应的基础功能，因此 `mmap` 与 `munmap` 实现也分为不同层级的实现
- syscall: 确定用户要map/unmap的虚拟内存地址范围，并判断权限是否合法，构造相应的 `VirtAddr`， `MapPermission`
- memory set: 提供 `insert_framed_area` 与 `remove_area` 的入口，主要功能在于通过传入的参数构造一个 `MemArea`， 然后将` MemArea` 插入/移除当前task的 Memory Set。实际实现中我将此功能入口封装在task manager 中，以方便获取task相关信息
- memory area: 逐页映射虚拟页 -> 物理页


## 简答作业


### 1

页表项从高位到低位分别是
- 保留
- 物理页号: `[53:10]`
- RSW: 预留给系统管理员使用
- 标志位: `[7:0]`
  - V(Valid): 仅当位 V 为 1 时，页表项才是合法的
  - R(Read)/W(Write)/X(eXecute): 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行
  - U(User): 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
  - G(Global): 全局映射，用于TLB
  - A(Accessed): 处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
  - D(Dirty): 处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过

### 2

1. Riscv中有一系列与 `Page fault` 相关的异常: Instruction Page Fault、Load Page Faul、Store Page Fault、Fetch Page Fault
2. 缺页异常会导致MMU返回一个中断，并在 `scause` 设置导致缺页中断的原因

1. 减少task驻留在内存时所需要的内存大小

1. 数十kb
2. 简单思路就是，映射地址时只设置页表，而不进行物理页的分配，而当page fault发生时，再分配物理页并更新对应的页表项

1. 标志为中标记为非法页

### 3

1. 修改页表基地址，即通过 `satp` 切换
2. 设置标志项 U
3. 方便访问用户地址空间中的数据，不必软件走页
4. 陷入内核/任务切换时需要更换页表，仅在切换任务时更新页表

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。